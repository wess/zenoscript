#include "c_backend.h"
#include "backend.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Type mapping table for Zenoscript -> C
static TypeMapping c_type_mappings[] = {
    {ZIR_TYPE_VOID, "void"},
    {ZIR_TYPE_BOOL, "bool"},
    {ZIR_TYPE_INT, "int"},
    {ZIR_TYPE_FLOAT, "double"},
    {ZIR_TYPE_STRING, "char*"},
    {ZIR_TYPE_ATOM, "int"}  // Atoms as enums
};

ZenoBackend* c_backend_create(void) {
    ZenoBackend* backend = malloc(sizeof(ZenoBackend));
    if (!backend) return NULL;
    
    backend->name = strdup("c");
    backend->version = strdup("1.0.0");
    backend->description = strdup("ANSI C code generator");
    
    // Set function pointers
    backend->init = c_backend_init;
    backend->cleanup = c_backend_cleanup;
    backend->generate_header = c_backend_generate_header;
    backend->generate_struct = c_backend_generate_struct;
    backend->generate_trait = c_backend_generate_trait;
    backend->generate_function = c_backend_generate_function;
    backend->generate_expression = c_backend_generate_expression;
    backend->generate_statement = c_backend_generate_statement;
    backend->generate_type = c_backend_generate_type;
    backend->generate_footer = c_backend_generate_footer;
    backend->map_type = c_backend_map_type;
    backend->map_operator = c_backend_map_operator;
    
    // File properties
    backend->file_extension = strdup(".c");
    backend->header_extension = strdup(".h");
    backend->needs_header_file = true;
    backend->supports_generics = false;  // C doesn't have generics
    backend->supports_gc = false;
    backend->supports_manual_memory = true;
    
    // Initialize backend data
    CBackendData* data = malloc(sizeof(CBackendData));
    data->header_includes = sb_create();
    data->type_declarations = sb_create();
    data->function_declarations = sb_create();
    data->main_code = sb_create();
    data->needs_string_lib = false;
    data->needs_stdio = false;
    data->needs_stdlib = false;
    data->needs_stdbool = false;
    
    backend->backend_data = data;
    
    return backend;
}

int c_backend_init(ZenoBackend* backend) {
    CBackendData* data = (CBackendData*)backend->backend_data;
    
    // Always need these for Zenoscript features
    data->needs_stdio = true;   // For console.log equivalents
    data->needs_stdlib = true;  // For malloc/free
    data->needs_stdbool = true; // For bool type
    
    return 0;
}

void c_backend_cleanup(ZenoBackend* backend) {
    if (backend->backend_data) {
        CBackendData* data = (CBackendData*)backend->backend_data;
        sb_free(data->header_includes);
        sb_free(data->type_declarations);
        sb_free(data->function_declarations);
        sb_free(data->main_code);
        free(data);
    }
    
    free(backend->name);
    free(backend->version);
    free(backend->description);
    free(backend->file_extension);
    free(backend->header_extension);
    free(backend);
}

char* c_backend_generate_header(ZIRModule* module) {
    StringBuilder* sb = sb_create();
    
    sb_append_line(sb, "/* Generated by ZenoVM C Backend */");
    sb_append_line(sb, "#include <stdio.h>");
    sb_append_line(sb, "#include <stdlib.h>");
    sb_append_line(sb, "#include <string.h>");
    sb_append_line(sb, "#include <stdbool.h>");
    sb_append_line(sb, "");
    
    // Add forward declarations
    sb_append_line(sb, "/* Forward declarations */");
    
    char* result = sb_to_string(sb);
    sb_free(sb);
    return result;
}

char* c_backend_generate_struct(ZIRNode* node) {
    if (node->type != ZIR_STRUCT_DECL) {
        return strdup("/* Error: not a struct declaration */");
    }
    
    StringBuilder* sb = sb_create();
    
    if (node->struct_decl.is_empty) {
        // Empty struct
        sb_appendf(sb, "typedef struct {} %s;\n", node->struct_decl.name);
    } else {
        sb_appendf(sb, "typedef struct {\n");
        sb_increase_indent(sb);
        
        // Generate fields
        for (int i = 0; i < node->struct_decl.fields->count; i++) {
            ZIRNode* field = zir_list_get(node->struct_decl.fields, i);
            if (field->type == ZIR_IDENTIFIER) {
                // Simple field (need to enhance ZIR to have proper field declarations)
                sb_append_indent(sb);
                sb_appendf(sb, "char* %s;  /* TODO: proper type */\n", field->identifier.name);
            }
        }
        
        sb_decrease_indent(sb);
        sb_appendf(sb, "} %s;\n", node->struct_decl.name);
    }
    
    char* result = sb_to_string(sb);
    sb_free(sb);
    return result;
}

char* c_backend_generate_function(ZIRNode* node) {
    if (node->type != ZIR_FUNCTION_DECL) {
        return strdup("/* Error: not a function declaration */");
    }
    
    StringBuilder* sb = sb_create();
    
    // Return type
    char* return_type = "void";
    if (node->function_decl.return_type) {
        return_type = c_backend_map_type(node->function_decl.return_type);
    }
    
    sb_appendf(sb, "%s %s(", return_type, node->function_decl.name);
    
    // Parameters
    if (node->function_decl.params && node->function_decl.params->count > 0) {
        for (int i = 0; i < node->function_decl.params->count; i++) {
            if (i > 0) sb_append(sb, ", ");
            ZIRNode* param = zir_list_get(node->function_decl.params, i);
            sb_appendf(sb, "void* %s", param->identifier.name);  // TODO: proper types
        }
    } else {
        sb_append(sb, "void");
    }
    
    sb_append_line(sb, ") {");
    sb_increase_indent(sb);
    
    // Function body
    if (node->function_decl.body) {
        char* body = c_backend_generate_statement(node->function_decl.body);
        sb_append_indent(sb);
        sb_append(sb, body);
        free(body);
    }
    
    // Handle optional return
    if (node->function_decl.has_optional_return) {
        sb_append_line(sb, "");
        sb_append_indent(sb);
        sb_append_line(sb, "/* TODO: Handle optional return */");
    }
    
    sb_decrease_indent(sb);
    sb_append_line(sb, "}");
    
    char* result = sb_to_string(sb);
    sb_free(sb);
    return result;
}

char* c_backend_generate_expression(ZIRNode* node) {
    if (!node) return strdup("NULL");
    
    switch (node->type) {
        case ZIR_IDENTIFIER:
            return strdup(node->identifier.name);
            
        case ZIR_LITERAL:
            return c_backend_generate_literal(node);
            
        case ZIR_CALL_EXPR:
            return c_backend_generate_call_expr(node);
            
        case ZIR_BINARY_OP:
            return c_backend_generate_binary_op(node);
            
        case ZIR_PIPE_EXPR:
            return c_backend_generate_pipe_expr(node);
            
        case ZIR_MATCH_EXPR:
            return c_backend_generate_match_expr(node);
            
        default:
            return strdup("/* TODO: Expression type not implemented */");
    }
}

char* c_backend_generate_literal(ZIRNode* node) {
    StringBuilder* sb = sb_create();
    
    switch (node->literal.lit_type) {
        case ZIR_LIT_BOOL:
            sb_append(sb, node->literal.bool_value ? "true" : "false");
            break;
            
        case ZIR_LIT_INT:
            sb_appendf(sb, "%ld", node->literal.int_value);
            break;
            
        case ZIR_LIT_FLOAT:
            sb_appendf(sb, "%f", node->literal.float_value);
            break;
            
        case ZIR_LIT_STRING:
            sb_appendf(sb, "\"%s\"", c_backend_escape_string_c(node->literal.string_value));
            break;
            
        case ZIR_LIT_ATOM:
            sb_appendf(sb, "ATOM_%s", node->literal.atom_value);  // Convert to enum
            break;
            
        case ZIR_LIT_NULL:
            sb_append(sb, "NULL");
            break;
    }
    
    char* result = sb_to_string(sb);
    sb_free(sb);
    return result;
}

char* c_backend_generate_call_expr(ZIRNode* node) {
    StringBuilder* sb = sb_create();
    
    char* function = c_backend_generate_expression(node->call_expr.function);
    sb_append(sb, function);
    sb_append(sb, "(");
    
    // Arguments
    if (node->call_expr.args && node->call_expr.args->count > 0) {
        for (int i = 0; i < node->call_expr.args->count; i++) {
            if (i > 0) sb_append(sb, ", ");
            ZIRNode* arg = zir_list_get(node->call_expr.args, i);
            char* arg_str = c_backend_generate_expression(arg);
            sb_append(sb, arg_str);
            free(arg_str);
        }
    }
    
    sb_append(sb, ")");
    
    free(function);
    char* result = sb_to_string(sb);
    sb_free(sb);
    return result;
}

char* c_backend_map_type(ZIRType* zir_type) {
    return backend_map_type_generic(zir_type, c_type_mappings, 
                                   sizeof(c_type_mappings) / sizeof(TypeMapping));
}

char* c_backend_map_operator(ZIRBinaryOp op) {
    switch (op) {
        case ZIR_OP_ADD: return "+";
        case ZIR_OP_SUB: return "-";
        case ZIR_OP_MUL: return "*";
        case ZIR_OP_DIV: return "/";
        case ZIR_OP_MOD: return "%";
        case ZIR_OP_EQ:  return "==";
        case ZIR_OP_NE:  return "!=";
        case ZIR_OP_LT:  return "<";
        case ZIR_OP_LE:  return "<=";
        case ZIR_OP_GT:  return ">";
        case ZIR_OP_GE:  return ">=";
        case ZIR_OP_AND: return "&&";
        case ZIR_OP_OR:  return "||";
        case ZIR_OP_PIPE: return "/* pipe */";
        default: return "/* unknown op */";
    }
}

char* c_backend_generate_footer(ZIRModule* module) {
    StringBuilder* sb = sb_create();
    
    sb_append_line(sb, "");
    sb_append_line(sb, "int main(int argc, char* argv[]) {");
    sb_append_line(sb, "    /* TODO: Generate main function */");
    sb_append_line(sb, "    return 0;");
    sb_append_line(sb, "}");
    
    char* result = sb_to_string(sb);
    sb_free(sb);
    return result;
}

char* c_backend_escape_string_c(const char* str) {
    // TODO: Implement proper C string escaping
    return strdup(str);
}

// Stub implementations for remaining functions
char* c_backend_generate_trait(ZIRNode* node) {
    return strdup("/* Traits not supported in C backend */");
}

char* c_backend_generate_statement(ZIRNode* node) {
    return c_backend_generate_expression(node);
}

char* c_backend_generate_type(ZIRType* type) {
    return c_backend_map_type(type);
}

char* c_backend_generate_match_expr(ZIRNode* node) {
    return strdup("/* TODO: Match expressions */");
}

char* c_backend_generate_pipe_expr(ZIRNode* node) {
    return strdup("/* TODO: Pipe expressions */");
}

char* c_backend_generate_binary_op(ZIRNode* node) {
    StringBuilder* sb = sb_create();
    
    char* left = c_backend_generate_expression(node->binary_op.left);
    char* right = c_backend_generate_expression(node->binary_op.right);
    char* op = c_backend_map_operator(node->binary_op.op);
    
    sb_appendf(sb, "(%s %s %s)", left, op, right);
    
    free(left);
    free(right);
    char* result = sb_to_string(sb);
    sb_free(sb);
    return result;
}

char* c_backend_generate_runtime_calls(ZenoRuntime* runtime) {
    return strdup("/* Runtime calls not implemented */");
}